using UnityEngine;

public class EnemyMovement : MonoBehaviour
{
    [Header("References")]
    [SerializeField] private Rigidbody2D rb; // Referência ao Rigidbody2D do inimigo

    [Header("Attributes")]
    [SerializeField] private float moveSpeed = 2f;       // Velocidade de movimento
    [SerializeField] private float rotationSpeed = 10f;  // Controla a suavidade da rotação

    private Transform target;  // Próximo ponto do caminho que o inimigo deve seguir
    private int pathIndex = 0; // Índice do ponto atual no caminho

    private void Start()
    {
        // Define o primeiro alvo do caminho no início do jogo
        target = LevelManager.main.path[pathIndex];
    }

    private void Update()
    {
        // Verifica se o inimigo chegou suficientemente perto do ponto atual
        if (Vector2.Distance(transform.position, target.position) <= 0.1f)
        {
            pathIndex++;

            // Se chegou ao fim do caminho, o inimigo causa dano ao jogador
            if (pathIndex == LevelManager.main.path.Length)
            {
                // Diminui a vida do jogador com base no dano do inimigo
                Health_LB1 health = GetComponent<Health_LB1>();
                LevelManager.main.life -= health != null ? health.Damage : 1;

                // Notifica o sistema de spawn e destrói o inimigo
                EnemySpawner.onEnemyDestroy.Invoke();
                Destroy(gameObject);
                return;
            }
            else
            {
                // Atualiza o próximo ponto do caminho
                target = LevelManager.main.path[pathIndex];
            }

            // Caso a vida do jogador chegue a zero
            if (LevelManager.main.life <= 0)
            {
                LevelManager.main.life = 0;
                Destroy(gameObject);
            }
        }
    }

    private void FixedUpdate()
    {
        // Calcula a direção normalizada entre o inimigo e o ponto de destino
        Vector2 direction = (target.position - transform.position).normalized;

        // Move o inimigo na direção do ponto
        rb.linearVelocity = direction * moveSpeed;

        // Calcula o ângulo da direção em radianos e converte para graus
        float angle = Mathf.Atan2(direction.y, direction.x) * Mathf.Rad2Deg;

        // Ajusta o ângulo com base na orientação do sprite (90° é comum para sprites voltados para cima)
        float targetRotation = angle - 90f;

        // Gera uma rotação suave entre a rotação atual e a desejada
        transform.rotation = Quaternion.Lerp(
            transform.rotation,                                      // Rotação atual
            Quaternion.AngleAxis(targetRotation, Vector3.forward),   // Nova rotação desejada (em torno do eixo Z)
            Time.fixedDeltaTime * rotationSpeed                      // Controla a suavidade
        );
    }
}
